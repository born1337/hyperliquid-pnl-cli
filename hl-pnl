#!/bin/bash

# ══════════════════════════════════════════════════════════════════════════════
# hl-pnl - Hyperliquid Position PnL CLI
# A command-line tool to monitor Hyperliquid wallet/vault positions and PnL
# ══════════════════════════════════════════════════════════════════════════════

VERSION="1.3.0"

# ══════════════════════════════════════════════════════════════════════════════
# Check required dependencies
# ══════════════════════════════════════════════════════════════════════════════
check_dependencies() {
    local missing=()

    if ! command -v curl &>/dev/null; then
        missing+=("curl")
    fi

    if ! command -v jq &>/dev/null; then
        missing+=("jq")
    fi

    if ! command -v awk &>/dev/null; then
        missing+=("awk")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Error: Missing required dependencies: ${missing[*]}" >&2
        echo "" >&2
        echo "Install with:" >&2
        if [[ "$(uname)" == "Darwin" ]]; then
            echo "  brew install ${missing[*]}" >&2
        else
            echo "  sudo apt-get install ${missing[*]}" >&2
        fi
        exit 1
    fi
}

# Run dependency check immediately
check_dependencies

# Default values
WATCH_INTERVAL=0
ADDRESS=""
USE_TESTNET=false
OUTPUT_JSON=false
NO_COLOR=false
SHOW_VAULTS=false
API_URL="https://api.hyperliquid.xyz/info"
TESTNET_API_URL="https://api.hyperliquid-testnet.xyz/info"

# Colors (will be disabled if NO_COLOR is true)
setup_colors() {
    if [[ "$NO_COLOR" == true ]] || [[ ! -t 1 ]]; then
        # No color mode or not a terminal (piping)
        GREEN=''
        RED=''
        YELLOW=''
        CYAN=''
        MAGENTA=''
        WHITE=''
        DIM=''
        BOLD=''
        NC=''
    else
        GREEN='\033[0;92m'
        RED='\033[0;91m'
        YELLOW='\033[0;93m'
        CYAN='\033[0;96m'
        MAGENTA='\033[0;95m'
        WHITE='\033[1;97m'
        DIM='\033[0;90m'
        BOLD='\033[1m'
        NC='\033[0m'
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
# Helper function to format numbers with commas
# ══════════════════════════════════════════════════════════════════════════════
format_number() {
    local num="$1"
    local decimals="${2:-2}"

    # Use printf to format with commas via locale or awk
    echo "$num" | awk -v dec="$decimals" '{
        # Round to specified decimals
        multiplier = 10 ^ dec
        rounded = int($1 * multiplier + 0.5) / multiplier

        # Split into integer and decimal parts
        split(sprintf("%." dec "f", rounded), parts, ".")
        integer = parts[1]
        decimal = parts[2]

        # Add commas to integer part
        n = length(integer)
        result = ""
        for (i = 1; i <= n; i++) {
            if (i > 1 && (n - i + 1) % 3 == 0) {
                result = result ","
            }
            result = result substr(integer, i, 1)
        }

        # Handle negative numbers (remove incorrectly placed comma after minus)
        if (result ~ /^-,/) {
            result = "-" substr(result, 3)
        }

        print result "." decimal
    }'
}

# ══════════════════════════════════════════════════════════════════════════════
# Help function
# ══════════════════════════════════════════════════════════════════════════════
show_help() {
    setup_colors
    echo -e "${CYAN}══════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}${BOLD}hl-pnl${NC} - Hyperliquid Position PnL CLI (v${VERSION})"
    echo -e "${CYAN}══════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${WHITE}DESCRIPTION${NC}"
    echo "  A command-line tool to monitor Hyperliquid wallet and vault positions."
    echo "  Displays real-time PnL, margin info, leverage, and position details."
    echo "  Uses Hyperliquid's public API - no authentication required."
    echo ""
    echo -e "${WHITE}USAGE${NC}"
    echo -e "  ${GREEN}hl-pnl${NC} <address> [options]"
    echo ""
    echo -e "${WHITE}ARGUMENTS${NC}"
    echo -e "  ${YELLOW}<address>${NC}              Wallet or vault address (0x...)"
    echo ""
    echo -e "${WHITE}OPTIONS${NC}"
    echo -e "  ${YELLOW}-w, --watch <seconds>${NC}  Auto-refresh every N seconds (min: 5)"
    echo -e "  ${YELLOW}-V, --vaults${NC}           Show vault investments for wallet address"
    echo -e "  ${YELLOW}-t, --testnet${NC}          Use testnet API instead of mainnet"
    echo -e "  ${YELLOW}-j, --json${NC}             Output raw JSON (for scripting)"
    echo -e "  ${YELLOW}    --no-color${NC}         Disable colored output"
    echo -e "  ${YELLOW}-h, --help${NC}             Show this help message"
    echo -e "  ${YELLOW}-v, --version${NC}          Show version number"
    echo ""
    echo -e "${WHITE}EXAMPLES${NC}"
    echo -e "  ${DIM}# Check positions once${NC}"
    echo -e "  ${GREEN}hl-pnl 0x4cb5f4d145cd16460932bbb9b871bb6fd5db97e3${NC}"
    echo ""
    echo -e "  ${DIM}# Watch positions every 30 seconds${NC}"
    echo -e "  ${GREEN}hl-pnl 0x4cb5f4d145cd16460932bbb9b871bb6fd5db97e3 --watch 30${NC}"
    echo ""
    echo -e "  ${DIM}# Use testnet${NC}"
    echo -e "  ${GREEN}hl-pnl 0x... --testnet${NC}"
    echo ""
    echo -e "  ${DIM}# Output JSON for scripting${NC}"
    echo -e "  ${GREEN}hl-pnl 0x... --json | jq '.marginSummary.accountValue'${NC}"
    echo ""
    echo -e "  ${DIM}# Pipe to file (auto-disables colors)${NC}"
    echo -e "  ${GREEN}hl-pnl 0x... > positions.txt${NC}"
    echo ""
    echo -e "  ${DIM}# Show vault investments for a wallet${NC}"
    echo -e "  ${GREEN}hl-pnl 0x... --vaults${NC}"
    echo ""
    echo -e "${WHITE}OUTPUT FIELDS${NC}"
    echo -e "  ${YELLOW}Account Value${NC}     Total account value in USD"
    echo -e "  ${YELLOW}Position Value${NC}    Total notional value of all positions"
    echo -e "  ${YELLOW}Margin Used${NC}       Initial margin used"
    echo -e "  ${YELLOW}Maint. Margin${NC}     Maintenance margin requirement"
    echo -e "  ${YELLOW}Withdrawable${NC}      Available balance for withdrawal"
    echo -e "  ${YELLOW}Cross Leverage${NC}    Position Value / Account Value"
    echo -e "  ${YELLOW}Margin Ratio${NC}      Maint. Margin / Account Value (liquidation risk)"
    echo ""
    echo -e "${WHITE}MARGIN RATIO ALERTS${NC}"
    echo -e "  ${GREEN}< 50%${NC}              Safe"
    echo -e "  ${YELLOW}50-80%${NC}             Caution"
    echo -e "  ${RED}> 80%${NC}              High Risk (approaching liquidation)"
    echo ""
    echo -e "${WHITE}API ENDPOINTS${NC}"
    echo "  Mainnet:  https://api.hyperliquid.xyz/info"
    echo "  Testnet:  https://api.hyperliquid-testnet.xyz/info"
    echo ""
    echo -e "${WHITE}EXIT CODES${NC}"
    echo "  0  Success"
    echo "  1  Invalid arguments or address"
    echo "  2  Network error (timeout, connection failed)"
    echo "  3  API error (rate limited, server error)"
    echo ""
    echo -e "${WHITE}MORE INFO${NC}"
    echo -e "  GitHub:   ${GREEN}https://github.com/born1337/hyperliquid-pnl-cli${NC}"
    echo "  Built with Claude Code"
    echo ""
    echo -e "${CYAN}══════════════════════════════════════════════════════════════════════════════${NC}"
}

# ══════════════════════════════════════════════════════════════════════════════
# Version function
# ══════════════════════════════════════════════════════════════════════════════
show_version() {
    echo "hl-pnl version ${VERSION}"
}

# ══════════════════════════════════════════════════════════════════════════════
# Parse arguments
# ══════════════════════════════════════════════════════════════════════════════
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        -w|--watch)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                WATCH_INTERVAL=$2
                if [[ $WATCH_INTERVAL -lt 5 ]]; then
                    echo "Warning: Minimum watch interval is 5 seconds. Using 5." >&2
                    WATCH_INTERVAL=5
                fi
                shift 2
            else
                echo "Error: --watch requires a numeric interval (e.g., --watch 30)" >&2
                exit 1
            fi
            ;;
        -t|--testnet)
            USE_TESTNET=true
            shift
            ;;
        -j|--json)
            OUTPUT_JSON=true
            shift
            ;;
        -V|--vaults)
            SHOW_VAULTS=true
            shift
            ;;
        --no-color)
            NO_COLOR=true
            shift
            ;;
        -*)
            echo "Error: Unknown option $1" >&2
            echo "Use --help for usage information" >&2
            exit 1
            ;;
        *)
            if [[ -z "$ADDRESS" ]]; then
                ADDRESS=$1
            else
                echo "Error: Multiple addresses provided" >&2
                exit 1
            fi
            shift
            ;;
    esac
done

# Setup colors after parsing arguments
setup_colors

# Set API URL based on testnet flag
if [[ "$USE_TESTNET" == true ]]; then
    API_URL="$TESTNET_API_URL"
fi

# ══════════════════════════════════════════════════════════════════════════════
# Validate address
# ══════════════════════════════════════════════════════════════════════════════
if [[ -z "$ADDRESS" ]]; then
    echo -e "${RED}Error: No address provided${NC}" >&2
    echo "" >&2
    echo "Usage: hl-pnl <address> [options]" >&2
    echo "       hl-pnl --help for more information" >&2
    exit 1
fi

if [[ ! "$ADDRESS" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
    echo -e "${RED}Error: Invalid address format${NC}" >&2
    echo "Address must be 0x followed by 40 hex characters" >&2
    exit 1
fi

# ══════════════════════════════════════════════════════════════════════════════
# Fetch data from API with proper error handling
# ══════════════════════════════════════════════════════════════════════════════
fetch_data() {
    local temp_file=$(mktemp)
    local http_code

    # Make request with timeout, capture HTTP code separately
    http_code=$(curl -s -w "%{http_code}" \
        --connect-timeout 10 \
        --max-time 30 \
        -X POST "$API_URL" \
        -H "Content-Type: application/json" \
        -d "{\"type\":\"clearinghouseState\",\"user\":\"$ADDRESS\"}" \
        -o "$temp_file" 2>/dev/null)

    local curl_exit=$?

    # Check for curl errors (network issues)
    if [[ $curl_exit -ne 0 ]]; then
        rm -f "$temp_file"
        case $curl_exit in
            6)  echo -e "${RED}Error: Could not resolve host. Check your internet connection.${NC}" >&2 ;;
            7)  echo -e "${RED}Error: Failed to connect to API. Server may be down.${NC}" >&2 ;;
            28) echo -e "${RED}Error: Request timed out. API may be slow or unreachable.${NC}" >&2 ;;
            *)  echo -e "${RED}Error: Network error (curl exit code: $curl_exit)${NC}" >&2 ;;
        esac
        return 2
    fi

    # Check HTTP status code
    case $http_code in
        200)
            # Success - check if response is valid JSON
            if ! jq -e . "$temp_file" >/dev/null 2>&1; then
                echo -e "${RED}Error: Invalid JSON response from API${NC}" >&2
                rm -f "$temp_file"
                return 3
            fi

            # Check for API error in response
            if jq -e '.error' "$temp_file" >/dev/null 2>&1; then
                local error_msg=$(jq -r '.error' "$temp_file")
                echo -e "${RED}Error: API returned error: $error_msg${NC}" >&2
                rm -f "$temp_file"
                return 3
            fi

            cat "$temp_file"
            rm -f "$temp_file"
            return 0
            ;;
        429)
            echo -e "${RED}Error: Rate limited. Please wait before making more requests.${NC}" >&2
            rm -f "$temp_file"
            return 3
            ;;
        500|502|503|504)
            echo -e "${RED}Error: API server error (HTTP $http_code). Try again later.${NC}" >&2
            rm -f "$temp_file"
            return 3
            ;;
        *)
            echo -e "${RED}Error: Unexpected HTTP status code: $http_code${NC}" >&2
            rm -f "$temp_file"
            return 3
            ;;
    esac
}

# ══════════════════════════════════════════════════════════════════════════════
# Fetch user's vault investments
# ══════════════════════════════════════════════════════════════════════════════
fetch_user_vaults() {
    local temp_file=$(mktemp)
    local http_code

    # Call userVaultEquities API
    http_code=$(curl -s -w "%{http_code}" \
        --connect-timeout 10 \
        --max-time 30 \
        -X POST "$API_URL" \
        -H "Content-Type: application/json" \
        -d "{\"type\":\"userVaultEquities\",\"user\":\"$ADDRESS\"}" \
        -o "$temp_file" 2>/dev/null)

    local curl_exit=$?

    if [[ $curl_exit -ne 0 ]]; then
        rm -f "$temp_file"
        return 2
    fi

    if [[ "$http_code" == "200" ]]; then
        if jq -e . "$temp_file" >/dev/null 2>&1; then
            cat "$temp_file"
            rm -f "$temp_file"
            return 0
        fi
    fi

    rm -f "$temp_file"
    return 3
}

# ══════════════════════════════════════════════════════════════════════════════
# Fetch vault details
# ══════════════════════════════════════════════════════════════════════════════
fetch_vault_details() {
    local vault_address="$1"
    local temp_file=$(mktemp)
    local http_code

    # Call vaultDetails API
    http_code=$(curl -s -w "%{http_code}" \
        --connect-timeout 10 \
        --max-time 30 \
        -X POST "$API_URL" \
        -H "Content-Type: application/json" \
        -d "{\"type\":\"vaultDetails\",\"vaultAddress\":\"$vault_address\",\"user\":\"$ADDRESS\"}" \
        -o "$temp_file" 2>/dev/null)

    local curl_exit=$?

    if [[ $curl_exit -ne 0 ]]; then
        rm -f "$temp_file"
        return 2
    fi

    if [[ "$http_code" == "200" ]]; then
        if jq -e . "$temp_file" >/dev/null 2>&1; then
            cat "$temp_file"
            rm -f "$temp_file"
            return 0
        fi
    fi

    rm -f "$temp_file"
    return 3
}

# ══════════════════════════════════════════════════════════════════════════════
# Display vault investments
# ══════════════════════════════════════════════════════════════════════════════
display_vault_investments() {
    local vaults_response="$1"

    # Check if user has any vault investments
    local vault_count=$(echo "$vaults_response" | jq -r 'length')

    if [[ "$vault_count" -eq 0 || "$vaults_response" == "[]" ]]; then
        echo ""
        echo -e "${CYAN}────────────────────────────────────────────────────────────────────────────────────────${NC}"
        echo -e "${WHITE}${BOLD}VAULT INVESTMENTS${NC}"
        echo -e "${CYAN}────────────────────────────────────────────────────────────────────────────────────────${NC}"
        echo ""
        echo -e "${DIM}No vault investments found for this wallet${NC}"
        return 0
    fi

    echo ""
    echo -e "${CYAN}────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo -e "${WHITE}${BOLD}VAULT INVESTMENTS (${vault_count})${NC}"
    echo -e "${CYAN}────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo ""
    echo -e "${DIM}VAULT                          YOUR EQUITY           YOUR PNL           ALL-TIME PNL${NC}"
    echo -e "${DIM}─────────────────────────────────────────────────────────────────────────────────────────${NC}"

    local total_vault_equity=0
    local total_vault_pnl=0

    # Process each vault
    echo "$vaults_response" | jq -r '.[] | [.vaultAddress, .equity] | @tsv' | while IFS=$'\t' read -r vault_addr equity; do
        # Fetch vault details
        local vault_details
        vault_details=$(fetch_vault_details "$vault_addr")

        if [[ $? -eq 0 && -n "$vault_details" ]]; then
            # Parse vault info (single jq call)
            local vault_info
            vault_info=$(echo "$vault_details" | jq -r '[
                .name // "Unknown",
                .followerState.pnl // 0,
                .followerState.allTimePnl // 0,
                .followerState.vaultEquity // 0
            ] | @tsv')

            local vault_name user_pnl all_time_pnl vault_equity
            IFS=$'\t' read -r vault_name user_pnl all_time_pnl vault_equity <<< "$vault_info"

            # Use vault equity from details if available (more accurate)
            if [[ -n "$vault_equity" && "$vault_equity" != "0" && "$vault_equity" != "null" ]]; then
                equity="$vault_equity"
            fi

            # Format values
            local fmt_equity=$(format_number "$equity")
            local fmt_pnl=$(format_number "$user_pnl")
            local fmt_all_time=$(format_number "$all_time_pnl")

            # Truncate vault name if too long
            local display_name="$vault_name"
            if [[ ${#display_name} -gt 28 ]]; then
                display_name="${display_name:0:25}..."
            fi

            # Determine PnL colors
            local pnl_color="$GREEN"
            local pnl_sign="+"
            if (( $(awk "BEGIN {print ($user_pnl < 0)}") )); then
                pnl_color="$RED"
                pnl_sign=""
            fi

            local all_time_color="$GREEN"
            local all_time_sign="+"
            if (( $(awk "BEGIN {print ($all_time_pnl < 0)}") )); then
                all_time_color="$RED"
                all_time_sign=""
            fi

            printf "${WHITE}%-30s${NC} \$%-20s ${pnl_color}%s\$%-16s${NC} ${all_time_color}%s\$%s${NC}\n" \
                "$display_name" "$fmt_equity" "$pnl_sign" "$fmt_pnl" "$all_time_sign" "$fmt_all_time"
        else
            # Fallback if vault details fetch fails
            local fmt_equity=$(format_number "$equity")
            printf "${WHITE}%-30s${NC} \$%-20s ${DIM}N/A${NC}                ${DIM}N/A${NC}\n" \
                "${vault_addr:0:10}...${vault_addr: -6}" "$fmt_equity"
        fi
    done

    echo ""
}

# ══════════════════════════════════════════════════════════════════════════════
# Display formatted output
# ══════════════════════════════════════════════════════════════════════════════
display_formatted() {
    local response="$1"

    # Display timestamp if watching
    if [[ $WATCH_INTERVAL -gt 0 ]]; then
        local network_label="mainnet"
        [[ "$USE_TESTNET" == true ]] && network_label="testnet"
        echo -e "${DIM}Last updated: $(date '+%Y-%m-%d %H:%M:%S') | ${network_label} | Refreshing every ${WATCH_INTERVAL}s | Ctrl+C to stop${NC}"
        echo ""
    fi

    # Parse data (single jq call for all account-level fields)
    local parsed_data
    parsed_data=$(echo "$response" | jq -r '[
        .marginSummary.accountValue // 0,
        .marginSummary.totalNtlPos // 0,
        .marginSummary.totalMarginUsed // 0,
        .crossMaintenanceMarginUsed // 0,
        .withdrawable // 0,
        (.assetPositions | length)
    ] | @tsv')

    local account_value total_position margin_used maint_margin withdrawable positions_count
    IFS=$'\t' read -r account_value total_position margin_used maint_margin withdrawable positions_count <<< "$parsed_data"

    # Calculate derived values
    local cross_leverage=$(echo "$account_value $total_position" | awk '{if ($1 > 0) printf "%.2f", $2/$1; else print "0.00"}')
    local margin_ratio=$(echo "$account_value $maint_margin" | awk '{if ($1 > 0) printf "%.2f", ($2/$1)*100; else print "0.00"}')

    # Format numbers with commas
    local fmt_account=$(format_number "$account_value")
    local fmt_position=$(format_number "$total_position")
    local fmt_margin_used=$(format_number "$margin_used")
    local fmt_maint_margin=$(format_number "$maint_margin")
    local fmt_withdrawable=$(format_number "$withdrawable")

    # Determine margin ratio color and alert
    local margin_color="$GREEN"
    local margin_alert=""
    if (( $(awk "BEGIN {print ($margin_ratio > 80)}") )); then
        margin_color="$RED"
        margin_alert=" ⚠️  HIGH RISK"
    elif (( $(awk "BEGIN {print ($margin_ratio > 50)}") )); then
        margin_color="$YELLOW"
        margin_alert=" ⚠️  CAUTION"
    fi

    # Header
    echo -e "${CYAN}════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}${BOLD}                            HYPERLIQUID POSITION PNL${NC}"
    echo -e "${CYAN}════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""

    # Network indicator
    if [[ "$USE_TESTNET" == true ]]; then
        echo -e "${DIM}Address: ${ADDRESS}${NC} ${YELLOW}[TESTNET]${NC}"
    else
        echo -e "${DIM}Address: ${ADDRESS}${NC}"
    fi
    echo ""

    # Account summary
    echo -e "${WHITE}Account Value:${NC}      ${GREEN}\$${fmt_account}${NC}"

    if [[ "$positions_count" -eq 0 ]]; then
        echo -e "${WHITE}Withdrawable:${NC}       ${GREEN}\$${fmt_withdrawable}${NC}"
        echo ""
        echo -e "${YELLOW}No open positions${NC}"
        echo ""
        echo -e "${CYAN}════════════════════════════════════════════════════════════════════════════════════════${NC}"
        return 0
    fi

    echo -e "${WHITE}Position Value:${NC}     \$${fmt_position}"
    echo -e "${WHITE}Margin Used:${NC}        \$${fmt_margin_used}"
    echo -e "${WHITE}Maint. Margin:${NC}      \$${fmt_maint_margin}"
    echo -e "${WHITE}Withdrawable:${NC}       ${GREEN}\$${fmt_withdrawable}${NC}"
    echo ""
    echo -e "${WHITE}Cross Leverage:${NC}     ${MAGENTA}${cross_leverage}x${NC}"
    echo -e "${WHITE}Margin Ratio:${NC}       ${margin_color}${margin_ratio}%${NC}${margin_alert}"
    echo ""

    # Positions table
    echo -e "${CYAN}────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo -e "${WHITE}${BOLD}OPEN POSITIONS (${positions_count})${NC}"
    echo -e "${CYAN}────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo ""
    echo -e "${DIM}COIN      SIDE   LEV    SIZE               ENTRY          VALUE           PNL            ROE${NC}"
    echo -e "${DIM}──────────────────────────────────────────────────────────────────────────────────────────────────${NC}"

    # Process each position (single jq call extracts all fields)
    echo "$response" | jq -r '.assetPositions | sort_by(.position.unrealizedPnl | tonumber) | reverse | .[] | [
        .position.coin,
        .position.szi,
        .position.entryPx,
        .position.positionValue,
        .position.unrealizedPnl,
        .position.returnOnEquity,
        (.position.leverage.value // "?")
    ] | @tsv' | while IFS=$'\t' read -r coin szi entry_px pos_value pnl roe lev; do
        # Determine side and colors
        local side side_color pnl_color pnl_sign roe_color roe_sign

        # Side
        if (( $(awk "BEGIN {print ($szi < 0)}") )); then
            side="SHORT"; side_color="$RED"
        else
            side="LONG"; side_color="$GREEN"
        fi

        # PnL color
        if (( $(awk "BEGIN {print ($pnl < 0)}") )); then
            pnl_color="$RED"; pnl_sign=""
        else
            pnl_color="$GREEN"; pnl_sign="+"
        fi

        # ROE color
        if (( $(awk "BEGIN {print ($roe < 0)}") )); then
            roe_color="$RED"; roe_sign=""
        else
            roe_color="$GREEN"; roe_sign="+"
        fi

        # Computed values using awk (2 decimal places)
        local abs_size=$(awk "BEGIN {printf \"%.2f\", ($szi < 0) ? -($szi) : $szi}")
        local roe_pct=$(awk "BEGIN {printf \"%.2f\", $roe * 100}")
        local fmt_entry=$(awk "BEGIN {printf \"%.2f\", $entry_px}")
        local fmt_value=$(format_number "$pos_value")
        local fmt_pnl=$(format_number "$pnl")

        # Print position row (colors match Hyperliquid UI)
        printf "${WHITE}%-8s${NC} ${side_color}%-6s${NC} ${DIM}%-6s${NC} ${CYAN}%-18s${NC} \$%-13s \$%-15s ${pnl_color}%s\$%-12s${NC} ${pnl_color}(%s%s%%)${NC}\n" \
            "$coin" "$side" "${lev}x" "$abs_size" "$fmt_entry" "$fmt_value" "$pnl_sign" "$fmt_pnl" "$roe_sign" "$roe_pct"
    done

    # Calculate summary (single jq call)
    local summary_data
    summary_data=$(echo "$response" | jq -r '[
        ([.assetPositions[].position.unrealizedPnl | tonumber] | add // 0),
        ([.assetPositions[].position.unrealizedPnl | tonumber | select(. > 0)] | add // 0),
        ([.assetPositions[].position.unrealizedPnl | tonumber | select(. < 0)] | add // 0)
    ] | @tsv')

    local total_pnl winners losers
    IFS=$'\t' read -r total_pnl winners losers <<< "$summary_data"

    local fmt_winners=$(format_number "$winners")
    local fmt_losers=$(format_number "$losers")
    local fmt_total_pnl=$(format_number "$total_pnl")

    # Summary section
    echo ""
    echo -e "${CYAN}────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo -e "${WHITE}${BOLD}SUMMARY${NC}"
    echo -e "${CYAN}────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo ""
    echo -e "${WHITE}Winners:${NC}            ${GREEN}+\$${fmt_winners}${NC}"
    echo -e "${WHITE}Losers:${NC}             ${RED}\$${fmt_losers}${NC}"
    echo -e "${WHITE}Cross Leverage:${NC}     ${MAGENTA}${cross_leverage}x${NC}"
    echo -e "${WHITE}Margin Ratio:${NC}       ${margin_color}${margin_ratio}%${NC}"
    echo ""

    # Net PnL
    local pnl_color="$GREEN"
    local pnl_sign="+"
    if (( $(awk "BEGIN {print ($total_pnl < 0)}") )); then
        pnl_color="$RED"
        pnl_sign=""
    fi

    echo -e "${CYAN}════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}${BOLD}NET PNL:${NC}            ${pnl_color}${BOLD}${pnl_sign}\$${fmt_total_pnl}${NC}"
    echo -e "${CYAN}════════════════════════════════════════════════════════════════════════════════════════${NC}"
}

# ══════════════════════════════════════════════════════════════════════════════
# Main fetch and display function
# ══════════════════════════════════════════════════════════════════════════════
fetch_and_display() {
    local response
    response=$(fetch_data)
    local fetch_exit=$?

    if [[ $fetch_exit -ne 0 ]]; then
        return $fetch_exit
    fi

    # JSON output mode
    if [[ "$OUTPUT_JSON" == true ]]; then
        echo "$response" | jq '.'
        return 0
    fi

    # Formatted output
    display_formatted "$response"

    # Show vault investments if flag is set
    if [[ "$SHOW_VAULTS" == true ]]; then
        local vaults_response
        vaults_response=$(fetch_user_vaults)
        if [[ $? -eq 0 ]]; then
            display_vault_investments "$vaults_response"
        else
            echo ""
            echo -e "${YELLOW}Warning: Could not fetch vault investments${NC}"
        fi
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
# Main execution
# ══════════════════════════════════════════════════════════════════════════════
if [[ $WATCH_INTERVAL -gt 0 ]]; then
    # Watch mode - loop with clear screen
    trap 'echo -e "\n${YELLOW}Stopped watching.${NC}"; exit 0' INT
    while true; do
        clear
        fetch_and_display || true  # Continue watching even on error
        sleep $WATCH_INTERVAL
    done
else
    # Single run
    fetch_and_display
    exit $?
fi
